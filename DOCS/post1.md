리액트로 바위치기 #2 - URL로 이미지 동적 추가하기

## content

        리액트의 file import
        이미지 동적으로 렌더링 하기
        Uniform Resource Locator
        구현
        업로드
        URL 업/다운로드 오개념에 대해

# 리액트의 file import

메인페이지에서 보이는 카드 컴포넌트에 썸네일을 삽입하고 싶었다. 리액트에서는 import를 통해 이미지 파일을 출력할 수 있다.

```JS
import img1 from "../Assets/Images/img1.png";
```

이미지를 렌더링할 컴포넌트에 경로를 import 해주고, 정의한 객체를 JSX 안에 넣으면 이미지 출력이 가능하다.

### 모든 게시글마다 이미지를 import하는 하드코딩

이 방식으로 게시글의 이미지를 출력하게 되면 몇 가지 문제가 생긴다.

* 새로운 썸네일을 import 하기위해 글을 쓸 때마다 코드를 수정해야한다.
* 글을 삭제할 때도 import 했던 코드를 삭제해야한다.

지금이야 VScode만 실행해서 잠깐 수정하면 되지만, 블로그를 배포하게 되면 글을 쓰거나 지울 때마다 배포 서버에 접속해서 코드를 수정하고 다시 배포하는 복잡한 과정을 거쳐야한다.

### import를 동적으로 실행

안타깝게도 리액트에서는 import를 동적으로 런타임에 실행할 수 있는 기능이 없다.

그럼 리액트에서 이미지를 동적으로 가져오려면 어떻게 해야할까?

---

# 이미지 동적으로 렌더링 하기

찾아보니 세 가지 정도 방법이 있다.

### 1. 이미지 파일을 base64로 변환하기 

base64는 데이터를 바이너리 문자열로 변환하는 형식이다.
이미지의 각 픽셀 별 RGB 정보를 하나하나 다 읽어오는 로우레벨 방식이라고 할 수 있다. 그만큼 길이가 길어지고 사이크가 커지게 된다. 파일의 사이즈 뿐만 아니라 인코딩/디코딩 하는데에도 리소스가 과하게 사용된다.

### 2. 이미지 파일을 클라이언트에서 저장/관리하기 

이 방식은 이미지 파일을 주고받을 필요가 없어서 간단하긴 하지만 보안적으로 위험하기 때문에 서버-클라이언트 아키텍처의 장점을 살리지 못한다. 그리고 이미지의 동적 import 가 불가능한 문제는 해결되지 않는다.

### 3. **URL 을 통한 파일 업로드/다운로드**

리액트의 file import는 컴파일 타임에 이루어진다. STATIC 리소스를 가져오는 것과 동일하다. 이에 반해 url 방식은 url로 요청을 보낼 때(런타임에) 동적으로 이미지를 가져오기 때문에 import 없이도 이미지 출력이 가능하다.

![img1](http://localhost:8080/IMAGES/230607-3.jpeg)

그럼 url은 무엇일까?

---

# Uniform Resource Locator

> URL 은 리소스를 식별하기 위한 주소다!

리소스(파일)를 식별하기 위해 Uniform resource indicator(URI)을 사용한다. 이 URI는 URN과 URL로 나뉘어진다.

간단히 설명하자면, URN은 이름(NAME)을 통해서 리소스를 식별하고, URL은 주소/위치(Locator)를 통해서 리소스를 식별한다.

우리가 웹 사이트를 접속할 때 흔하게 접하는 URL은 프로토콜, 호스트, 포트번호, 경로, 쿼리, 프래그먼트로 이루어져있다.

![1](http://localhost:8080/IMAGES/230606-1.png)

### 프토토콜

프로토콜은 네트워크 상에서 서로 다른 이기종 기기들이 서로 통신하기 위해 정한 하나의 규칙이다. 프로토콜이란 말이 붙어있으면 다 규칙이라고 봐도 무방하다.

### 호스트

호스트는 엔드디바이스의 주소를 표현한다. 네트워크에 접속한 모든 디바이스는 고유한 ip address를 가지고있는데, ip주소는 외우기 힘드니까 DNS를 통해서 ip주소를 문자열 형태로 변환시킨다.

www.naver.com 등이 호스트의 예시이다. 이 주소로 접속하면 디바이스가 www.naver.com의 ip주소가 뭔지 DNS 서버에게 통신해서 질의하게 되고, DNS서버는 문자열에 맞는 ip주소를 디바이스에게 응답한다. 디바이스는 이 ip주소를 기반으로 해당 웹사이트에 접속하게 되는 것이다.

### 포트번호

포트번호는 보통 번호마다 하는 일이 정해져있다. 80번 포트는 웹 접속에 쓰인다. 정해진 포트번호로 접속이 들어오면 뭘 바라고 나한테 접속한 건지 판단하게된다. 예를 들어 www.naver.com:80에 접속하면 네이버 서버는 "아, 네이버 웹 사이트에 접속하고 싶어하는구나"라고 판단하게 된다.

### 경로

해당 호스트에게서 원하는 정보의 경로를 나타낸다. 정해진 경로를 통해서 원하는 데이터를 전송받을 수 있게 된다.

### 쿼리

### 프래그먼트

클라이언트에서 URL로 파일 다운로드를 하려고 서버에 보내는 요청은 GET 요청이다. 요청을 한다고 원하는 데이터를 다 받는 것은 아니고 해당 호스트가 요청에 적절한 응답을 해줘서 파일을 다운로드하거나, HTML을 렌더링받거나, RESTful API의 경우엔 원하는 데이터를 전송받을 수 있다.

---

# 구현

* 리액트에서 URL 요청
```js
<img className="postcard-image" alt="img" src="http://localhost:8080/Images/img9.jpeg"/>
```

리액트에서 이미지 파일을 URL로 전달받기 위해서 img 태그의 src 속성을 이용한다.
src에 URL을 입력하면 이 JSX가 렌더링 될 때 호스트인 localhost의 8080번 포트에 /Images/img9.jpeg 경로에 있는 파일을 GET 요청하게 되는 것이다.


* 서버에서 GET요청 응답 구현
```go
eg.GET("/Images/*", func (c *gin.Context){
    file, err := os.Open("src/Images/img9.jpeg")
    if err != nil {
        http.Error(c.Writer, "Failed to open file", http.StatusInternalServerError)
        return
    }
    defer file.Close()
    _, err = io.Copy(c.Writer, file)
    if err != nil {
    http.Error(c.Writer, "Failed to send file", http.StatusInternalServerError)
    return
    }
})
```

내가 구현한 GO 서버에서는 Images 경로로 GET 요청이 들어오면 img9.jpeg 파일을 열고, 파일을 Writer 포인터에 write 하는 방식으로 구현했다.

이렇게 구현하게 되면 클라이언트-서버간에 통신을 하고 파일을 전달해줄 수 있지만, 동적으로 클라이언트가 요청하는 파일을 선택해서 전달해줄 순 없다.

이때 URL의 파라미터를 통해서 동적으로 원하는 파일이 무엇인지 서버가 파악할 수 있다.

* 동적으로 수정하기
```go
eg.GET("/Images/:imgname", func (c *gin.Context){
        imgname := c.Param("imgname")
        file, err := os.Open("src/Images/"+imgname)
        ...
})
```
imgname이라는 파라미터의 값을 Param method를 이용해서 받고, 받은 파라미터에 맞는 파일을 열어서 클라이언트에 응답해줄 수 있다.

---

# 업로드

> 다운로드는 알겠는데, 그럼 업로드는 어떻게 하지?


업로드는 첫 번째 프로젝트에서 이미 구현해봤다. 사용자가 이미지 파일을 multipart/form-data 형식으로 POST 요청을 보내면 서버에서는 전달받은 요청본문의 데이터를 디코딩하고, 이미지를 서버에 저장할 수 있다. 
multipart/form-data 형식은 일반적인 plain/text 형식이 아니기 때문에 헤더를 통해서 content-type을 명시해줘야 오류없이 파일을 잘 전달받을 수 있다. 

파일 업로드 기능이 구현될 admin page는 블로그 개발의 가장 마지막에 구현하려고 기획 중에 있다. 우선 대부분의 데이터는 하드코딩 된 더미데이터로 구현하고 나중에 리팩토링 하면서 동적으로 수정한 후에, 마지막으로 admin page를 구현할 예정이다.

이번 블로그 프로젝트에서 BE/FE를 분리해서 개발하고 있긴 하지만 결국 배포는 인스턴스 하나에 포트만 달리해서 배포하게 될텐데, 이번 프로젝트를 마무리하고 docker/container/k8s에 대해 공부해서 다음 프로젝트에는 FE/BE/DB를 각각 다른 컨테이너에 올리는 가상화를 시도해봐야겠다.

마지막으로 이미지 다운로드를 구현하면서 새롭게 배운 것을 공유하고 글을 마무리 지으려고 한다.

# URL 업/다운로드 오개념에 대해

> 파일을 업로드하면 파일은 어디 숨어있다가 다운로드할 때 튀어나오는거지..?

파일의 업/다운로드의 개념에 대해 잘못알고 있었다가 이번에 리액트로 파일 다운로드를 구현하면서 잘못된 지식을 바로잡게 되었다. 이전에 내가 잘못 알고있던 업/다운로드에 대한 개념은 다음과 같다.

        클라이언트(서버) ---(업로드)-->(매개체)
        (매개체)---(다운로드)--> 서버(클라이언트)

그 동안 이 개념을 가지고있어서, 파일 전송엔 매개체가 필요하다고 생각했고 그 매개체가 특정 웹브라우저인지, 아니면 어떤 회사에서 파일 전송을 위한 서버를 제공해주나? 하는 의문을 가지고있었다.

일반적으로 업로드와 다운로드는 사용자 입장에서 정의된다.

        업로드 : 클라이언트 ---> 서버
        다운로드 : 서버 ---> 클라이언트